import numpy as np
import pandas as pd

def flatten(foo):
    for x in foo:
        if hasattr(x, '__iter__') and not isinstance(x, str):
            for y in flatten(x):
                yield y
        else:
            yield x

#
### Create statistics dataframe, comparing satellite and field data
#
def create_manystats(ls8_array, ls8_usgs_array, ls8_bad_days, ground_brdf_ls8, field_data):

    #
    # Set up band names for Landsat
    #
    l8_names = ['coastal_aerosol', 'blue', 'green', 'red', 'nir', 'swir1', 'swir2']
    l8_nums = ['band1', 'band2', 'band3', 'band4', 'band5', 'band6', 'band7']

    ########################
    # LANDSAT 8 PROCESSING #
    ########################
    #
    # Define list of times (format: YYY-MM-DD) to iterate over.
    # Based on xarray for satellite data.
    # One for each of the mean and standard deviation data columns.
    #
    meanls8 = ['ls8_mean'+str(i)[:10] for i in ls8_array.time.values]
    stdls8 = ['ls8_std'+str(i)[:10] for i in ls8_array.time.values]
    meanuls8 = ['ls8_mean'+str(i)[:10] for i in ls8_usgs_array.time.values]
    stduls8 = ['ls8_std'+str(i)[:10] for i in ls8_usgs_array.time.values]

    #
    # Create a list of calculated mean and SD values for each overpass of satellite
    #
    ls8list = []
    for m in range(len(l8_names)):
        bnd = [str(l8_nums[m]),
               [float(ls8_array[str(l8_names[m])].isel(time=[i]).mean())/10000 for i in range(len(ls8_array.time))],
               [float(ls8_array[str(l8_names[m])].isel(time=[j]).std())/10000 for j in range(len(ls8_array.time))],
               float(ground_brdf_ls8[str(l8_nums[m])].mean()),
               float(ground_brdf_ls8[str(l8_nums[m])].std())
              ]
        ls8list.append(list(flatten(bnd)))

    ls8ulist = []
    for m in range(len(l8_names)):
        bnd = [str(l8_nums[m]),
               [float(ls8_usgs_array[str(l8_names[m])].isel(time=[i]).mean())/10000 for i in range(len(ls8_usgs_array.time))],
               [float(ls8_usgs_array[str(l8_names[m])].isel(time=[j]).std())/10000 for j in range(len(ls8_usgs_array.time))],
               float(ground_brdf_ls8[str(l8_nums[m])].mean()),
               float(ground_brdf_ls8[str(l8_nums[m])].std())
              ]
        ls8ulist.append(list(flatten(bnd)))

    #
    # Create numpy array of all data, using headers generated by meanls8 and stdls8
    # Data comes from calculated lists above.
    # Data includes mean and SD values for both satellite (all dates)
    # and field data (just one date)
    #
    data_array = np.array([['', *meanls8, *stdls8, 'Field_mean', 'Field_SD'],
                            ls8list[0], ls8list[1], ls8list[2], ls8list[3], ls8list[4],
                            ls8list[5], ls8list[6]
                           ])
    #
    data_usgs_array = np.array([['', *meanuls8, *stduls8, 'Field_mean', 'Field_SD'],
                            ls8ulist[0], ls8ulist[1], ls8ulist[2], ls8ulist[3], ls8ulist[4],
                            ls8ulist[5], ls8ulist[6]
                           ])

    #
    # Convert numpy array to pandas dataframe
    #
    ls8_df = pd.DataFrame(data=data_array[1:,1:],
                      index=data_array[1:,0],
                      columns=data_array[0,1:])
    
    ls8_usgs_df = pd.DataFrame(data=data_usgs_array[1:,1:],
                      index=data_usgs_array[1:,0],
                      columns=data_usgs_array[0,1:])

    #
    # Add in columns for mean/SD, Satmean/Fieldmean and FieldSD/Fieldmean.
    # Based on previous pandas dataframe.
    #
    for i in ls8_array.time.values:
        ls8_df['ls8_SD'+str(i)[:10]+'/mean (%)'] = 100*ls8_df['ls8_std'+str(i)[:10]].astype(float)/ls8_df['ls8_mean'+str(i)[:10]].astype(float)
        ls8_df['ls8'+str(i)[:10]+'/Field'] = ls8_df['ls8_mean'+str(i)[:10]].astype(float)/ls8_df['Field_mean'].astype(float) 

    ls8_df['Field_SD/mean (%)'] = 100*ls8_df['Field_SD'].astype(float)/ls8_df['Field_mean'].astype(float)

    for i in ls8_usgs_array.time.values:
        ls8_usgs_df['ls8_SD'+str(i)[:10]+'/mean (%)'] = 100*ls8_usgs_df['ls8_std'+str(i)[:10]].astype(float)/ls8_usgs_df['ls8_mean'+str(i)[:10]].astype(float)
        ls8_usgs_df['ls8'+str(i)[:10]+'/Field'] = ls8_usgs_df['ls8_mean'+str(i)[:10]].astype(float)/ls8_usgs_df['Field_mean'].astype(float) 

    ls8_usgs_df['Field_SD/mean (%)'] = 100*ls8_usgs_df['Field_SD'].astype(float)/ls8_usgs_df['Field_mean'].astype(float)

    #
    # Remove columns that are manually identified as bad data due to clouds
    # These were not picked up by LS8 Pixel Quality or Sentinel Quality masks.
    #
    for i in ls8_bad_days:
        ls8_df.drop('ls8_mean'+str(i), axis=1, inplace=True)
        ls8_df.drop('ls8_std'+str(i), axis=1, inplace=True)
        ls8_df.drop('ls8_SD'+str(i)+'/mean (%)', axis=1, inplace=True)
        ls8_df.drop('ls8'+str(i)+'/Field', axis=1, inplace=True)

    for i in ls8_bad_days:
        try:
            ls8_usgs_df.drop('ls8_mean'+str(i), axis=1, inplace=True)
            ls8_usgs_df.drop('ls8_std'+str(i), axis=1, inplace=True)
            ls8_usgs_df.drop('ls8_SD'+str(i)+'/mean (%)', axis=1, inplace=True)
            ls8_usgs_df.drop('ls8'+str(i)+'/Field', axis=1, inplace=True)
        except KeyError:
            continue

    # 
    # Convert all numbers to floats
    #
    fls8_df = ls8_df.astype(float)
    fls8_usgs_df = ls8_usgs_df.astype(float)

    #
    # Drop all columns that have Nans (bad data, usually due to clouds)
    #
    fls8_df.drop(fls8_df.columns[fls8_df.isna().any()], axis=1, inplace=True)
    fls8_usgs_df.drop(fls8_usgs_df.columns[fls8_usgs_df.isna().any()], axis=1, inplace=True)
    fls8_usgs_df.drop(fls8_usgs_df.columns[fls8_usgs_df.iloc[0] < 0.0], axis=1, inplace=True)


    return fls8_df, fls8_usgs_df
