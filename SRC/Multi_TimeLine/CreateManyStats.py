import numpy as np
import pandas as pd

def flatten(foo):
    for x in foo:
        if hasattr(x, '__iter__') and not isinstance(x, str):
            for y in flatten(x):
                yield y
        else:
            yield x

#
### Create statistics dataframe, comparing satellite and field data
#
def create_manystats(ls8_array, s2a_array, s2b_array, ls8_bad_days, s2a_bad_days, s2b_bad_days, ground_brdf_ls8, ground_brdf_s2a, field_data):

    #
    # Set up band names for Landsat
    #
    l8_names = ['nbart_coastal_aerosol', 'nbart_blue', 'nbart_green',
                'nbart_red', 'nbart_nir', 'nbart_swir_1', 'nbart_swir_2']
    l8_nums = ['band1', 'band2', 'band3', 'band4', 'band5', 'band6', 'band7']

    #
    # Set up band names for Sentinel
    #
    s2_names = ['nbart_coastal_aerosol', 'nbart_blue', 'nbart_green',
                'nbart_red', 'nbart_red_edge_1', 'nbart_red_edge_2',
                'nbart_red_edge_3', 'nbart_nir_1', 'nbart_nir_2',
                'nbart_swir_2', 'nbart_swir_3']
    s2_nums = ['band1', 'band2', 'band3', 'band4', 'band5', 'band6',
               'band7', 'band8', 'band8a', 'band11', 'band12']

    ########################
    # LANDSAT 8 PROCESSING #
    ########################
    #
    # Define list of times (format: YYY-MM-DD) to iterate over.
    # Based on xarray for satellite data.
    # One for each of the mean and standard deviation data columns.
    #
    meanls8 = ['ls8_mean'+str(i)[:10] for i in ls8_array.time.values]
    stdls8 = ['ls8_std'+str(i)[:10] for i in ls8_array.time.values]

    #
    # Create a list of calculated mean and SD values for each overpass of satellite
    #
    ls8list = []
    if isinstance(ground_brdf_ls8, pd.DataFrame):
        for m in range(len(l8_names)):
            bnd = [str(l8_nums[m]),
                   [float(ls8_array[str(l8_names[m])].isel(time=[i]).mean())/10000 for i in range(len(ls8_array.time))],
                   [float(ls8_array[str(l8_names[m])].isel(time=[j]).std())/10000 for j in range(len(ls8_array.time))],
                   float(ground_brdf_ls8[str(l8_nums[m])].mean()),
                   float(ground_brdf_ls8[str(l8_nums[m])].std())
                  ]
            ls8list.append(list(flatten(bnd)))
    else:
        for m in range(len(l8_names)):
            bnd = [str(l8_nums[m]),
                   [float(ls8_array[str(l8_names[m])].isel(time=[i]).mean())/10000 for i in range(len(ls8_array.time))],
                   [float(ls8_array[str(l8_names[m])].isel(time=[j]).std())/10000 for j in range(len(ls8_array.time))]]
            ls8list.append(list(flatten(bnd)))

    #
    # Create numpy array of all data, using headers generated by meanls8 and stdls8
    # Data comes from calculated lists above.
    # Data includes mean and SD values for both satellite (all dates)
    # and field data (just one date)
    #
    #import pdb; pdb.set_trace()
    if isinstance(ground_brdf_ls8, pd.DataFrame):
        data_array = np.array([['', *meanls8, *stdls8, 'Field_mean', 'Field_SD'],
                                ls8list[0], ls8list[1], ls8list[2], ls8list[3], ls8list[4],
                                ls8list[5], ls8list[6]
                               ])
    else:
        data_array = np.array([['', *meanls8, *stdls8],#, 'Field_mean', 'Field_SD'],
                                ls8list[0], ls8list[1], ls8list[2], ls8list[3], ls8list[4],
                                ls8list[5], ls8list[6]
                               ])
    #
    # Convert numpy array to pandas dataframe
    #
    ls8_df = pd.DataFrame(data=data_array[1:,1:],
                      index=data_array[1:,0],
                      columns=data_array[0,1:])
    #
    # Add in columns for mean/SD, Satmean/Fieldmean and FieldSD/Fieldmean.
    # Based on previous pandas dataframe.
    #
    if isinstance(ground_brdf_ls8, pd.DataFrame):
        for i in ls8_array.time.values:
            ls8_df['ls8_SD'+str(i)[:10]+'/mean (%)'] = 100*ls8_df['ls8_std'+str(i)[:10]].astype(float)/ls8_df['ls8_mean'+str(i)[:10]].astype(float)
            ls8_df['ls8'+str(i)[:10]+'/Field'] = ls8_df['ls8_mean'+str(i)[:10]].astype(float)/ls8_df['Field_mean'].astype(float) 
        ls8_df['Field_SD/mean (%)'] = 100*ls8_df['Field_SD'].astype(float)/ls8_df['Field_mean'].astype(float)
    else:
        for i in ls8_array.time.values:
            ls8_df['ls8_SD'+str(i)[:10]+'/mean (%)'] = 100*ls8_df['ls8_std'+str(i)[:10]].astype(float)/ls8_df['ls8_mean'+str(i)[:10]].astype(float)

    #
    # Remove columns that are manually identified as bad data due to clouds
    # These were not picked up by LS8 Pixel Quality or Sentinel Quality masks.
    #
    if isinstance(ground_brdf_ls8, pd.DataFrame):
        for i in ls8_bad_days:
            ls8_df.drop('ls8_mean'+str(i), axis=1, inplace=True)
            ls8_df.drop('ls8_std'+str(i), axis=1, inplace=True)
            ls8_df.drop('ls8_SD'+str(i)+'/mean (%)', axis=1, inplace=True)
            ls8_df.drop('ls8'+str(i)+'/Field', axis=1, inplace=True)
    else:
        for i in ls8_bad_days:
            ls8_df.drop('ls8_mean'+str(i), axis=1, inplace=True)
            ls8_df.drop('ls8_std'+str(i), axis=1, inplace=True)
            ls8_df.drop('ls8_SD'+str(i)+'/mean (%)', axis=1, inplace=True)

    # 
    # Convert all numbers to floats
    #
    fls8_df = ls8_df.astype(float)

    #
    # Drop all columns that have Nans (bad data, usually due to clouds)
    #
    fls8_df.drop(fls8_df.columns[fls8_df.isna().any()], axis=1, inplace=True)


    ###############
    # SENTINEL 2A #
    ###############

    means2a = ['S2a_mean'+str(i)[:10] for i in s2a_array.time.values]
    stds2a = ['S2a_std'+str(i)[:10] for i in s2a_array.time.values]

    s2alist = []
    if isinstance(ground_brdf_s2a, pd.DataFrame):
        for m in range(len(s2_names)):
            bnd = [str(s2_nums[m]),
                   [float(s2a_array[str(s2_names[m])].isel(time=[i]).mean())/10000 for i in range(len(s2a_array.time))],
                   [float(s2a_array[str(s2_names[m])].isel(time=[j]).std())/10000 for j in range(len(s2a_array.time))],
                   float(ground_brdf_s2a[str(s2_nums[m])].mean()),
                   float(ground_brdf_s2a[str(s2_nums[m])].std())
                  ]
            s2alist.append(list(flatten(bnd)))
    else:
        for m in range(len(s2_names)):
            bnd = [str(s2_nums[m]),
                   [float(s2a_array[str(s2_names[m])].isel(time=[i]).mean())/10000 for i in range(len(s2a_array.time))],
                   [float(s2a_array[str(s2_names[m])].isel(time=[j]).std())/10000 for j in range(len(s2a_array.time))]]
            s2alist.append(list(flatten(bnd)))

    if isinstance(ground_brdf_s2a, pd.DataFrame):
        data_array = np.array([['', *means2a, *stds2a, 'Field_mean', 'Field_SD'],
                                s2alist[0], s2alist[1], s2alist[2], s2alist[3], s2alist[4],
                                s2alist[5], s2alist[6], s2alist[7], s2alist[8], s2alist[9],
                                s2alist[10]
                               ])
    else:
        data_array = np.array([['', *means2a, *stds2a],
                                s2alist[0], s2alist[1], s2alist[2], s2alist[3], s2alist[4],
                                s2alist[5], s2alist[6], s2alist[7], s2alist[8], s2alist[9],
                                s2alist[10]
                               ])

    s2a_df = pd.DataFrame(data=data_array[1:,1:],
                      index=data_array[1:,0],
                      columns=data_array[0,1:])

    if isinstance(ground_brdf_s2a, pd.DataFrame):
        for i in s2a_array.time.values:
            s2a_df['S2a_SD'+str(i)[:10]+'/mean (%)'] = 100*s2a_df['S2a_std'+str(i)[:10]].astype(float)/s2a_df['S2a_mean'+str(i)[:10]].astype(float)
            s2a_df['S2a'+str(i)[:10]+'/Field'] = s2a_df['S2a_mean'+str(i)[:10]].astype(float)/s2a_df['Field_mean'].astype(float) 
        s2a_df['Field_SD/mean (%)'] = 100*s2a_df['Field_SD'].astype(float)/s2a_df['Field_mean'].astype(float)
    else:
        for i in s2a_array.time.values:
            s2a_df['S2a_SD'+str(i)[:10]+'/mean (%)'] = 100*s2a_df['S2a_std'+str(i)[:10]].astype(float)/s2a_df['S2a_mean'+str(i)[:10]].astype(float)

    if isinstance(ground_brdf_s2a, pd.DataFrame):
        for i in s2a_bad_days:
            s2a_df.drop('S2a_mean'+str(i), axis=1, inplace=True)
            s2a_df.drop('S2a_std'+str(i), axis=1, inplace=True)
            s2a_df.drop('S2a_SD'+str(i)+'/mean (%)', axis=1, inplace=True)
            s2a_df.drop('S2a'+str(i)+'/Field', axis=1, inplace=True)
    else:
        for i in s2a_bad_days:
            s2a_df.drop('S2a_mean'+str(i), axis=1, inplace=True)
            s2a_df.drop('S2a_std'+str(i), axis=1, inplace=True)

    fs2a_df = s2a_df.astype(float)

    #
    # Drop all columns that have Nans (bad data, usually due to clouds)
    #
    fs2a_df.drop(fs2a_df.columns[fs2a_df.isna().any()], axis=1, inplace=True)


    ###############
    # SENTINEL 2B #
    ###############

    means2b = ['S2b_mean'+str(i)[:10] for i in s2b_array.time.values]
    stds2b = ['S2b_std'+str(i)[:10] for i in s2b_array.time.values]

    s2blist = []
    if isinstance(ground_brdf_s2a, pd.DataFrame):
        for m in range(len(s2_names)):
            bnd = [str(s2_nums[m]),
                   [float(s2b_array[str(s2_names[m])].isel(time=[i]).mean())/10000 for i in range(len(s2b_array.time))],
                   [float(s2b_array[str(s2_names[m])].isel(time=[j]).std())/10000 for j in range(len(s2b_array.time))],
                   float(ground_brdf_s2a[str(s2_nums[m])].mean()),
                   float(ground_brdf_s2a[str(s2_nums[m])].std())
                  ]
            s2blist.append(list(flatten(bnd)))
    else:
        for m in range(len(s2_names)):
            bnd = [str(s2_nums[m]),
                   [float(s2b_array[str(s2_names[m])].isel(time=[i]).mean())/10000 for i in range(len(s2b_array.time))],
                   [float(s2b_array[str(s2_names[m])].isel(time=[j]).std())/10000 for j in range(len(s2b_array.time))]]
            s2blist.append(list(flatten(bnd)))

    if isinstance(ground_brdf_s2a, pd.DataFrame):
        data_array = np.array([['', *means2b, *stds2b, 'Field_mean', 'Field_SD'],
                                s2blist[0], s2blist[1], s2blist[2], s2blist[3], s2blist[4],
                                s2blist[5], s2blist[6], s2blist[7], s2blist[8], s2blist[9],
                                s2blist[10]
                               ])
    else:
        data_array = np.array([['', *means2b, *stds2b],
                                s2blist[0], s2blist[1], s2blist[2], s2blist[3], s2blist[4],
                                s2blist[5], s2blist[6], s2blist[7], s2blist[8], s2blist[9],
                                s2blist[10]
                               ])

    s2b_df = pd.DataFrame(data=data_array[1:,1:],
                      index=data_array[1:,0],
                      columns=data_array[0,1:])

    if isinstance(ground_brdf_s2a, pd.DataFrame):
        for i in s2b_array.time.values:
            s2b_df['S2b_SD'+str(i)[:10]+'/mean (%)'] = 100*s2b_df['S2b_std'+str(i)[:10]].astype(float)/s2b_df['S2b_mean'+str(i)[:10]].astype(float)
            s2b_df['S2b'+str(i)[:10]+'/Field'] = s2b_df['S2b_mean'+str(i)[:10]].astype(float)/s2b_df['Field_mean'].astype(float) 
        s2b_df['Field_SD/mean (%)'] = 100*s2b_df['Field_SD'].astype(float)/s2b_df['Field_mean'].astype(float)
    else:
        for i in s2b_array.time.values:
            s2b_df['S2b_SD'+str(i)[:10]+'/mean (%)'] = 100*s2b_df['S2b_std'+str(i)[:10]].astype(float)/s2b_df['S2b_mean'+str(i)[:10]].astype(float)

    if isinstance(ground_brdf_s2a, pd.DataFrame):
        for i in s2b_bad_days:
            s2b_df.drop('S2b_mean'+str(i), axis=1, inplace=True)
            s2b_df.drop('S2b_std'+str(i), axis=1, inplace=True)
            s2b_df.drop('S2b_SD'+str(i)+'/mean (%)', axis=1, inplace=True)
            s2b_df.drop('S2b'+str(i)+'/Field', axis=1, inplace=True)
    else:
        for i in s2b_bad_days:
            s2b_df.drop('S2b_mean'+str(i), axis=1, inplace=True)
            s2b_df.drop('S2b_std'+str(i), axis=1, inplace=True)

    fs2b_df = s2b_df.astype(float)

    #
    # Drop all columns that have Nans (bad data, usually due to clouds)
    #
    fs2b_df.drop(fs2b_df.columns[fs2b_df.isna().any()], axis=1, inplace=True)


    return fls8_df, fs2a_df, fs2b_df
